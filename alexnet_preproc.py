import tensorflow as tf
import numpy as np
import os
from scipy import misc
import skimage.io as io
from sklearn.feature_extraction import image
import matplotlib.pyplot as plt
import math
from PIL import Image
from numpy import int32

import sys
import glob
sys.path.insert(0,'.')
sys.path.insert(0,'../imagenetdata')

class datagetter:
  def __init__(self,synsetfile,impath,xmlpath,ending):
    pass
    self.indicestosynsets,self.synsetstoindices,self.synsetstoclassdescr=parsesynsetwords(synsetfile)
    self.imagelist= []
    self.xmlpath=xmlpath
    self.ending=ending
    self.counter=0

    for root, dirs, files in os.walk(impath):
    # generates filenames in directory tree by walking the tree
    # returns you directory path, directory names and filenames
      for f in files:
        fname = os.path.join(root, f)
        if fname.endswith(self.ending):
          # if the name ends with a suffix defined in list "ending", return True
          self.imagelist.append(fname)
    print('found',len(self.imagelist),'relevant files')

  def filenametoxml(self,fn):
    f = os.path.basename(fn)
    if not f.endswith(self.ending):
      print('not f.endswith(self.ending)')
      exit()

    f=f[:-len(self.ending)]+'.xml'
    f=os.path.join(self.xmlpath,f)
    return f

  def get_next_batch(self,batchsize):
    imlist = self.imagelist[self.counter:int(min(self.counter+batchsize,len(self.imagelist)))]
    self.counter+=batchsize

    # wrap around if at end of dataset
    diff=self.counter - len(self.imagelist)
    if(diff>0):
      imlist.extend(self.imagelist[0:diff] )
      self.counter=diff
    elif diff==0: # exactly at the end, haha
      self.counter=0

    labels=-np.ones((len(imlist)))

    for ct,f in enumerate(imlist):
      xmlfile=self.filenametoxml(f)
      label,_=parseclasslabel(xmlfile,self.synsetstoindices)
      labels[ct]=int(label)

    return imlist,labels


def resize(im, imsize): # Resize function for a single image input
  resizedIm = misc.imresize(im, imsize) # returns image file
  return resizedIm

def resize_and_extract_overlapping(imList, imSize, windowSize):
    # step size should be 0.5 * image dim, and windowSize = 32x32
    stepSize = (int(round(imSize[0]/2)), int(round(imSize[1]/2)))

    for imName in imList:
        im = io.imread(imName)
        resizedIm = resize(im, imSize)
        imgDim = (resizedIm.shape[0],resizedIm.shape[1])
        for y in range(0, imgDim[1], stepSize[1]):
            for x in range(0, imgDim[0], stepSize[0]):
                crop = im[x:x+windowSize[0], y:y + windowSize[1]]
                yield (x,y,crop) # yield gives back a generator object

def resize_and_extract_no_overlap(imList, imSize, stepSize, windowSize):
    # step size should be 1 * image dim, and windowSize = 32x32
    stepSize = (int(round(imSize[0])), int(round(imSize[1])))

    for imName in imList:
        im = io.imread(imName)
        resizedIm = resize(im, imSize)
        imgDim = (resizedIm.shape[0],resizedIm.shape[1])
        for y in range(0, imgDim[1], stepSize[1]):
            for x in range(0, imgDim[0], stepSize[0]):
                crop = im[x:x+windowSize[0], y:y + windowSize[1]]
                yield (x,y,crop) # yield gives back a generator object

if __name__=='__main__':

  imSize = (350,230)
  patchSize = (32,32)

  # For the code provided by prof, the imList will be generated by the datagetter instead
  # im assuming the format for that imlist is in the form of a file path; but i didn't confirm
  imList = glob.glob("/home/pf1404/Documents/ai_coding_tasks/project/test_images/*.png")

  for (x,y,crop) in resize_and_extract_overlapping(imList, imSize, patchSize):
      if crop.shape[0] != patchSize[0] or crop.shape[1] != patchSize[1]:
          continue
      plt.imshow(crop)
      plt.show()
      # this should be where the training code goes.
